#개발지식 #컨퍼런스

> [!tip]+ index
> - [[#연결문서|연결문서]]
> - [들어가기 전에](#들어가기%20전에)
> - [[#내용 정리|내용 정리]]
> 	- [[#내용 정리#1. 22년 7월 기능 조직에서 목적조직으로 변경|1. 22년 7월 기능 조직에서 목적조직으로 변경]]
> 	- [[#내용 정리#2. 1개의 레거시 프로젝트 N개의 목적조직의 불편한 동거|2. 1개의 레거시 프로젝트 N개의 목적조직의 불편한 동거]]
> 	- [[#내용 정리#3. 프로젝트 복제로 인해 생긴 문제점과 해결 과정|3. 프로젝트 복제로 인해 생긴 문제점과 해결 과정]]
> 	- [[#내용 정리#4. 다음 개선|4. 다음 개선]]
> - [[#느낀점|느낀점]]
> - [[#참고|참고]]
## 연결문서
- [index-컨퍼런스](../../../index-컨퍼런스.md)

## 들어가기 전에


## 발표내용 정리

### 1. 22년 7월 기능조직에서 목적조직으로 변경
회사의 규모가 커짐에 따른 비즈니스 속도를 유지하기 위해 기능 조직에서 목적조직으로 개편하였다.  

#### 기능조직
![기능조직 | 500](images/Pasted%20image%2020230909202556.png)
- 기능 조직은 안적적이지만 의사 결정이 늦게 되는 문제가 발생한다.
- 기능 조직에서 업무 플로우: PM 조직 회의 -> 디자이너 조직 회의 -> 개발 조직
- 기능 조직은 전문성이 높다.  -> 엔지니어끼리 가지는 문제를 서로의 도움으로 해결이 가능하다.

#### 목적조직
![목적조직 | 500](images/Pasted%20image%2020230909203159.png)
- 목적조직은 각 파트별로 최소 1명씩 참여하여 구성되기 때문에 특정 목적 빠르게 수행하기에 적합하다.
- 목적 조직에서 업무 플로우: Cell(스쿼드)안에서 목적을 달성하기 위한 빠른 의사결정
- 목적 조직은 파트를 담당하는 사람이 부제하는 경우 대응하기 힘들다는 단점이 존재한다.
- 가장 큰 문제는 장기적인 제품 속도, 회사의 안정성이 떨어진다는 문제를 가진다.

#### 목적조직 + 직군 조직(챕터, 파트) 합친 방법으로 개편
![목적+직군조직 | 500 ](images/Pasted%20image%2020230909204735.png)
- 비즈니스 속도를 유지하기 위해 목적조직을 유지하면서 목적조직의 문제점은 각 파트간에 교류를 통해 해결한다.  
- 매주 수요일 파트별 정기 미팅을 통한 장애, 기술공유
- 모든 PR을 파트별로 공용 채널에서 관리한다. 

### 2. 1개의 레거시 프로젝트 N개의 목적조직의 불편한 동거
인프런은 모노레포 형식의 거대한 레거시 프로젝트를 가지고 있다.
( [22년 인프콘의 발표](https://www.inflearn.com/course/lecture?courseSlug=infcon2022&unitId=126515)를 보면 자세히 알 수 있다.)

#### 문제 상황
![거대한레거시 | 500](images/Pasted%20image%2020230909205156.png)

레거시 시스템에는 FE, BE의 핵심 코드가 거의다 들어 있으며, 모든 목적 조직은 해당 프로젝트에 종속되어 있다.
하나의 레거시 프로젝트를 여러 목적 조직에서 사용하기 때문에 아래와 같은 문제가 발생한다.
- 점점 커지는 소스코드로 인해 늘어나는 빌드 속도
- 뒤섞이는 Commit 로그
- 서로 영향 받는 QA
- **단일 레거시 시스템의 개편은 어느 조직의 목표인지 책임을 결정할 수 없는 문제가 발생**
#### 해결 방법

[**MSA**]
이러한 경우의 문제 해결 방법에서 가장 많이 떠올리는 방법이 'MSA'라고 한다.
하지만 소규모 팀에서 MSA를 하는 것은 오히려 속도를 떨어지게 하는 문제를 가진다.  
(일반적으로 하나의 목적 조직이 2 ~ 3의 서비스를 관리하는 정도가 적합하다 한다.)  

[**분할정복**]
프로그래밍 세계에서 복잡한 문제를 해결 하는 방법의 대표 분할정복을 사용하여 문제를 해결한다.  

![분할정복 | 500](images/Pasted%20image%2020230909210724.png)
![TOBE1 |500](images/Pasted%20image%2020230909210935.png)
![TOBE2 | 500](images/Pasted%20image%2020230909211038.png)
결과적으로 목적 조직마다 1개의 작은 레거시 프로젝트 + 신규 스택 FE, BE 프로젝트를 가지게 된다.  
- 줄어든 코드만큼 개선된 빌드 속도
- 목적조직이 가진 프로젝트별로 관리되는 Commit 로그
- 독림된 프로젝트에서 격리된 QA
- **목적 조직마다 쪼게어 가지게된 레거시 코드의 개편은 목적 조직의 책임이 된다.**
### 3. 프로젝트 복제로 인해 생긴 문제점과 해결 과정
1개의 레거시 서비스가 N개의 소규모 레거시 프로젝트로 분할 -> 인프라 또한 N배로 증설해야 한다.
즉, 인프라 계층 전체의 복제가 필요하다.  
#### 문제 1) IaC 사용하여 인프라를 동일하게 복제 관리한다.
![pulumi | 500](images/Pasted%20image%2020230909212449.png)
- N개의 인프라를 매번 손으로 복제해야하는 문제를 IaC[^1]도구를 통해 해결한다.  
- pulumi를 사용한 이유
	- pulumi는 목적 조직에서 사용하는 개발언어 사용하여 코드를 작성할 수 있다.
	- 문서 품질이 가장 훌륭하다. 
	- (TS) ESLint/Prettier, 모노 레포 등으로 높은 품질의 관리가 된다.
	- (TS) Jest를 활용한 단위 테스트가 가능하다.
#### 문제 2) 1개의 URL Domain에 N개의 프로젝트 트래픽 분기
![cloudFront 동적라우팅 | 500](images/Pasted%20image%2020230909213451.png)
- Cloud Front를 사용하면 Load Balancer가 지원하지 않는 다양한 서비스로 라우팅 설정이 가능하다.
- 이 방식의 장점은 url path 별로 목적조직이 관리하는 API로 트래픽을 보낼 수 있는 점이다.  
- 가장 큰 단점은 단일 URL를 사용하여 질의를 하는 GraphQL을 도입할 수 없다는 점이다.  
#### 문제 3) 내부 API 통신이 많아진다 1.
프로젝트를 N개로 쪼게면 내부에서 (모듈끼리)서로 호출하는 코드는 API를 호출 하는 방식으로 변경해야 한다.  
이 때 내부 API 호출이 "Public IP 호출"인가 "Private IP 호출" 인가에 따라 네트워크 비용이 달라진다.


Public IP를 사용한 내부 통신의 문제점
![Public 내부 통신 | 500](images/Pasted%20image%2020230909214632.png)
- 내부에서 외부 DNS에 요청을 하기 때문에 네트워크 리소스가 높게 된다. 
	- HTTPS -> HTTP
	- 외부에서 내부로 트래픽이 들어오는 모든 과정을 매번 수행한다.
- 외부 트래픽으로 인해 트래픽 비용이 높게 잡힌다.
- 사내 또는 VPN 기반의 내부망 구성이 어렵게 된다.


Private (VPC) Load Balancer를 하나 더 사용하여 내부통신을 구성한다.
![pivate 내부 통신 | 500](images/Pasted%20image%2020230909215712.png)
- Public (VPC) Load Balancer은 DNS에서 들어오는 외부 트래픽을 처리한다.
- Private (VPC) Load Balancer 각 EC2는 Private elb의 주소를 바라보게한다.
	(ECS는 오케스트레이션 툴(k8s)에서 지원하는 내부 라우팅 기능을 사용할 수 없나?)

#### 문제 4) 내부 API 통신이 많아진다 2.
프로젝트를 쪼게어 내부 통신이 발생하면 결국 분산 서비스에서 발생하는 문제점이 똑같이 발생한다.  

client에서 호출된 영상 API의 서비스에서 여러 내부 API를 호출하는 경우 -> 모든 API가 성공해야 한다.  
![내부API 호출2 | 500](images/Pasted%20image%2020230909221323.png)
- 영상 API에서 다른 프로젝트의 로직까지 신경써야 하는가?
- API중 하나라도 실패하면 어떻게 할 것인가?
- 모든 API가 처리(성공 또는 실패)할 때까지 대기시간을 감수할 것인가?

이러한 문제를 해결할때는 보편적으로 큐를 통한 비동기 아키텍처를 도입하여 해결한다. (with SNS-SQS)
![SNS-SQS | 500](images/Pasted%20image%2020230909221708.png)
- SNS에 이벤트를 발행하게 하여 도메인 의존성을 분리한다.
- 발행된 메세지는 각 서비스 SQS에 전달한다. 
- SQS는 최종적 일관성을 보장하기 때문에 실패에 처리가 가능하다.
- 결과 적으로 영상 API는 자신의 로직만 처리하고 각 API의 결과를 기다릴 필요가 없게된다.

비동기 아키텍처 사용시 잊으면 안되는 주의점
- 트랜잭션이 필요한 곳에는 최대한 사용을 제한하는게 좋다.
	ex) 주문 서비스
- 즉, 여러 로직이 비동이로 실행되도 무방할 때 사용한다.
- 인프런에서는 단일 DB를 사용하기 때문에 트랜잭션이 있는 로직의 경우 직접 SQL을 실행하는 방법을 사용한다.

#### 문제 5) 단일 DB 문제점 (with ORM)

테이블 변경 사항에 대한 전체 조직의 Sync를 하기가 어렵다.  
![단일 DB 문제 해결1 | 500](images/Pasted%20image%2020230909223233.png)
- DDL 발생시 모든 목적 조직에게 공유한다. -> Slack 알림


부하나 지연이 발생하는 SQL 출처 파악이 어렵다.
![단일 DB 문제 해결2 | 500](images/Pasted%20image%2020230909223323.png)
- 문제가 발생하는 쿼리를 모든 목적 조직에게 공유한다 ->  Slack으로 알림이 오게한다.
- 이 때 오류 메시지에 프로젝트 지정한 DB 계정 정보를 포함한다.

중복된 도메인 클래스 관리에 대한 문제가 있다.  
![단일 DB 문제 해결3 | 500](images/Pasted%20image%2020230909223355.png)
- 목적 조직 별로 도메인 클래스를 가지며, 각 조직에 맞는 코드를 포함하게 한다.
- 즉, 공통화를 포기하고 중복된 클래스를 가지게 하는 방법을 사용한다.

중복된 도메인 클래스에 대한 이동욱님의 생각
> 불확실한 미래에는 어설픈 추상화/공통화 보다는  
> 삭제하기 쉬운 중복이 낮다.


### 4. 다음 개선 목표

#### 비즈니스에 독립적인 플렛폼 성격의 API 관리
이메일 / 문자 / 알림톡 발송 같은 목적조직이 관리하기에 부적합한 API의 경우 DevOps에서 관리한다.
![다음개선1 | 500](images/Pasted%20image%2020230909222746.png)
#### 인증, 권한을 한 곳에 관리하기 위한 최소한의 API Gateway 구축
![다음개선2 | 500](images/Pasted%20image%2020230909222802.png)
#### EndPoint 공유 방지를 위한 모노레포 구성
![다음개선3 | 500](images/Pasted%20image%2020230909222848.png)

## 느낀점


## 참고
- [인프런 아키텍처 2023 ~ 2024](https://www.inflearn.com/course/lecture?courseSlug=%EC%9D%B8%ED%94%84%EC%BD%982023-%EB%8B%A4%EC%8B%9C%EB%B3%B4%EA%B8%B0&unitId=177907)



[^1]: IaC(Infrastructure as Code): 코드로 인프라를 관리하는 기술로 절차형 IaC(pulumi)와 선언형 IaC(Terraform)가 있다.